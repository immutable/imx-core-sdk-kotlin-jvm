/**
 * Immutable X API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * Contact: support@immutable.com
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.immutable.sdk.api

import com.immutable.sdk.api.model.AddMetadataSchemaToCollectionRequest
import com.immutable.sdk.api.model.Asset
import com.immutable.sdk.api.model.CancelOrderRequest
import com.immutable.sdk.api.model.CancelOrderResponse
import com.immutable.sdk.api.model.Collection
import com.immutable.sdk.api.model.CollectionFilter
import com.immutable.sdk.api.model.CreateCollectionRequest
import com.immutable.sdk.api.model.CreateOrderRequest
import com.immutable.sdk.api.model.CreateOrderResponse
import com.immutable.sdk.api.model.CreateProjectRequest
import com.immutable.sdk.api.model.CreateProjectResponse
import com.immutable.sdk.api.model.CreateTradeRequestV1
import com.immutable.sdk.api.model.CreateTradeResponse
import com.immutable.sdk.api.model.CreateTransferRequest
import com.immutable.sdk.api.model.CreateTransferRequestV1
import com.immutable.sdk.api.model.CreateTransferResponse
import com.immutable.sdk.api.model.CreateTransferResponseV1
import com.immutable.sdk.api.model.CreateWithdrawalRequest
import com.immutable.sdk.api.model.CreateWithdrawalResponse
import com.immutable.sdk.api.model.Deposit
import com.immutable.sdk.api.model.GetBalanceResponse
import com.immutable.sdk.api.model.GetProjectsResponse
import com.immutable.sdk.api.model.GetSignableCancelOrderRequest
import com.immutable.sdk.api.model.GetSignableCancelOrderResponse
import com.immutable.sdk.api.model.GetSignableDepositRequest
import com.immutable.sdk.api.model.GetSignableDepositResponse
import com.immutable.sdk.api.model.GetSignableOrderRequest
import com.immutable.sdk.api.model.GetSignableOrderResponse
import com.immutable.sdk.api.model.GetSignableRegistrationRequest
import com.immutable.sdk.api.model.GetSignableRegistrationResponse
import com.immutable.sdk.api.model.GetSignableTradeRequest
import com.immutable.sdk.api.model.GetSignableTradeResponse
import com.immutable.sdk.api.model.GetSignableTransferRequest
import com.immutable.sdk.api.model.GetSignableTransferRequestV1
import com.immutable.sdk.api.model.GetSignableTransferResponse
import com.immutable.sdk.api.model.GetSignableTransferResponseV1
import com.immutable.sdk.api.model.GetSignableWithdrawalRequest
import com.immutable.sdk.api.model.GetSignableWithdrawalResponse
import com.immutable.sdk.api.model.GetUsersApiResponse
import com.immutable.sdk.api.model.ListAssetsResponse
import com.immutable.sdk.api.model.ListBalancesResponse
import com.immutable.sdk.api.model.ListCollectionsResponse
import com.immutable.sdk.api.model.ListDepositsResponse
import com.immutable.sdk.api.model.ListMintsResponse
import com.immutable.sdk.api.model.ListOrdersResponse
import com.immutable.sdk.api.model.ListTokensResponse
import com.immutable.sdk.api.model.ListTradesResponse
import com.immutable.sdk.api.model.ListTransfersResponse
import com.immutable.sdk.api.model.ListWithdrawalsResponse
import com.immutable.sdk.api.model.MetadataSchemaProperty
import com.immutable.sdk.api.model.MetadataSchemaRequest
import com.immutable.sdk.api.model.Mint
import com.immutable.sdk.api.model.MintRequest
import com.immutable.sdk.api.model.MintTokensResponse
import com.immutable.sdk.api.model.MintableTokenDetails
import com.immutable.sdk.api.model.Order
import com.immutable.sdk.api.model.Project
import com.immutable.sdk.api.model.RegisterUserRequestVerifyEth
import com.immutable.sdk.api.model.RegisterUserResponse
import com.immutable.sdk.api.model.SuccessResponse
import com.immutable.sdk.api.model.TokenDetails
import com.immutable.sdk.api.model.Trade
import com.immutable.sdk.api.model.Transfer
import com.immutable.sdk.api.model.UpdateCollectionRequest
import com.immutable.sdk.api.model.Withdrawal

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class PublicApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("org.openapitools.client.baseUrl", "https://api.ropsten.x.immutable.com")
        }
    }

    /**
    * Add metadata schema to collection
    * Add metadata schema to collection
    * @param address Collection contract address 
    * @param imXSignature String created by signing wallet address and timestamp 
    * @param imXTimestamp Unix Epoc timestamp 
    * @param addMetadataSchemaToCollectionRequest add metadata schema to a collection 
    * @return SuccessResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addMetadataSchemaToCollection(address: kotlin.String, imXSignature: kotlin.String, imXTimestamp: kotlin.String, addMetadataSchemaToCollectionRequest: AddMetadataSchemaToCollectionRequest) : SuccessResponse {
        val localVariableConfig = addMetadataSchemaToCollectionRequestConfig(address = address, imXSignature = imXSignature, imXTimestamp = imXTimestamp, addMetadataSchemaToCollectionRequest = addMetadataSchemaToCollectionRequest)

        val localVarResponse = request<AddMetadataSchemaToCollectionRequest, SuccessResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SuccessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation addMetadataSchemaToCollection
    *
    * @param address Collection contract address 
    * @param imXSignature String created by signing wallet address and timestamp 
    * @param imXTimestamp Unix Epoc timestamp 
    * @param addMetadataSchemaToCollectionRequest add metadata schema to a collection 
    * @return RequestConfig
    */
    fun addMetadataSchemaToCollectionRequestConfig(address: kotlin.String, imXSignature: kotlin.String, imXTimestamp: kotlin.String, addMetadataSchemaToCollectionRequest: AddMetadataSchemaToCollectionRequest) : RequestConfig<AddMetadataSchemaToCollectionRequest> {
        val localVariableBody = addMetadataSchemaToCollectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        imXSignature.apply { localVariableHeaders["IMX-Signature"] = this.toString() }
        imXTimestamp.apply { localVariableHeaders["IMX-Timestamp"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/collections/{address}/metadata-schema".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * cancel an order
    * Cancel an order
    * @param id Order ID to cancel 
    * @param cancelOrderRequest cancel an order 
    * @param xImxEthAddress eth address (optional)
    * @param xImxEthSignature eth signature (optional)
    * @return CancelOrderResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cancelOrder(id: kotlin.String, cancelOrderRequest: CancelOrderRequest, xImxEthAddress: kotlin.String?, xImxEthSignature: kotlin.String?) : CancelOrderResponse {
        val localVariableConfig = cancelOrderRequestConfig(id = id, cancelOrderRequest = cancelOrderRequest, xImxEthAddress = xImxEthAddress, xImxEthSignature = xImxEthSignature)

        val localVarResponse = request<CancelOrderRequest, CancelOrderResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CancelOrderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation cancelOrder
    *
    * @param id Order ID to cancel 
    * @param cancelOrderRequest cancel an order 
    * @param xImxEthAddress eth address (optional)
    * @param xImxEthSignature eth signature (optional)
    * @return RequestConfig
    */
    fun cancelOrderRequestConfig(id: kotlin.String, cancelOrderRequest: CancelOrderRequest, xImxEthAddress: kotlin.String?, xImxEthSignature: kotlin.String?) : RequestConfig<CancelOrderRequest> {
        val localVariableBody = cancelOrderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xImxEthAddress?.apply { localVariableHeaders["x-imx-eth-address"] = this.toString() }
        xImxEthSignature?.apply { localVariableHeaders["x-imx-eth-signature"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/v1/orders/{id}".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create collection
    * Create collection
    * @param imXSignature String created by signing wallet address and timestamp 
    * @param imXTimestamp Unix Epoc timestamp 
    * @param createCollectionRequest create a collection 
    * @return Collection
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createCollection(imXSignature: kotlin.String, imXTimestamp: kotlin.String, createCollectionRequest: CreateCollectionRequest) : Collection {
        val localVariableConfig = createCollectionRequestConfig(imXSignature = imXSignature, imXTimestamp = imXTimestamp, createCollectionRequest = createCollectionRequest)

        val localVarResponse = request<CreateCollectionRequest, Collection>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Collection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation createCollection
    *
    * @param imXSignature String created by signing wallet address and timestamp 
    * @param imXTimestamp Unix Epoc timestamp 
    * @param createCollectionRequest create a collection 
    * @return RequestConfig
    */
    fun createCollectionRequestConfig(imXSignature: kotlin.String, imXTimestamp: kotlin.String, createCollectionRequest: CreateCollectionRequest) : RequestConfig<CreateCollectionRequest> {
        val localVariableBody = createCollectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        imXSignature.apply { localVariableHeaders["IMX-Signature"] = this.toString() }
        imXTimestamp.apply { localVariableHeaders["IMX-Timestamp"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/collections",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create an order
    * Create an order
    * @param createOrderRequest create an order 
    * @param xImxEthAddress eth address (optional)
    * @param xImxEthSignature eth signature (optional)
    * @return CreateOrderResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createOrder(createOrderRequest: CreateOrderRequest, xImxEthAddress: kotlin.String?, xImxEthSignature: kotlin.String?) : CreateOrderResponse {
        val localVariableConfig = createOrderRequestConfig(createOrderRequest = createOrderRequest, xImxEthAddress = xImxEthAddress, xImxEthSignature = xImxEthSignature)

        val localVarResponse = request<CreateOrderRequest, CreateOrderResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateOrderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation createOrder
    *
    * @param createOrderRequest create an order 
    * @param xImxEthAddress eth address (optional)
    * @param xImxEthSignature eth signature (optional)
    * @return RequestConfig
    */
    fun createOrderRequestConfig(createOrderRequest: CreateOrderRequest, xImxEthAddress: kotlin.String?, xImxEthSignature: kotlin.String?) : RequestConfig<CreateOrderRequest> {
        val localVariableBody = createOrderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xImxEthAddress?.apply { localVariableHeaders["x-imx-eth-address"] = this.toString() }
        xImxEthSignature?.apply { localVariableHeaders["x-imx-eth-signature"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/orders",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create a project
    * Create a project
    * @param imXSignature String created by signing wallet address and timestamp 
    * @param imXTimestamp Unix Epoc timestamp 
    * @param createProjectRequest create a project 
    * @return CreateProjectResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createProject(imXSignature: kotlin.String, imXTimestamp: kotlin.String, createProjectRequest: CreateProjectRequest) : CreateProjectResponse {
        val localVariableConfig = createProjectRequestConfig(imXSignature = imXSignature, imXTimestamp = imXTimestamp, createProjectRequest = createProjectRequest)

        val localVarResponse = request<CreateProjectRequest, CreateProjectResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateProjectResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation createProject
    *
    * @param imXSignature String created by signing wallet address and timestamp 
    * @param imXTimestamp Unix Epoc timestamp 
    * @param createProjectRequest create a project 
    * @return RequestConfig
    */
    fun createProjectRequestConfig(imXSignature: kotlin.String, imXTimestamp: kotlin.String, createProjectRequest: CreateProjectRequest) : RequestConfig<CreateProjectRequest> {
        val localVariableBody = createProjectRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        imXSignature.apply { localVariableHeaders["IMX-Signature"] = this.toString() }
        imXTimestamp.apply { localVariableHeaders["IMX-Timestamp"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/projects",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create a Trade between two parties
    * Create a Trade
    * @param createTradeRequest create a trade 
    * @param xImxEthAddress eth address (optional)
    * @param xImxEthSignature eth signature (optional)
    * @return CreateTradeResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createTrade(createTradeRequest: CreateTradeRequestV1, xImxEthAddress: kotlin.String?, xImxEthSignature: kotlin.String?) : CreateTradeResponse {
        val localVariableConfig = createTradeRequestConfig(createTradeRequest = createTradeRequest, xImxEthAddress = xImxEthAddress, xImxEthSignature = xImxEthSignature)

        val localVarResponse = request<CreateTradeRequestV1, CreateTradeResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateTradeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation createTrade
    *
    * @param createTradeRequest create a trade 
    * @param xImxEthAddress eth address (optional)
    * @param xImxEthSignature eth signature (optional)
    * @return RequestConfig
    */
    fun createTradeRequestConfig(createTradeRequest: CreateTradeRequestV1, xImxEthAddress: kotlin.String?, xImxEthSignature: kotlin.String?) : RequestConfig<CreateTradeRequestV1> {
        val localVariableBody = createTradeRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xImxEthAddress?.apply { localVariableHeaders["x-imx-eth-address"] = this.toString() }
        xImxEthSignature?.apply { localVariableHeaders["x-imx-eth-signature"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/trades",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Creates a transfer of multiple tokens between two parties
    * Create a new transfer request
    * @param createTransferRequestV2 Create transfer 
    * @param xImxEthAddress eth address (optional)
    * @param xImxEthSignature eth signature (optional)
    * @return CreateTransferResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createTransfer(createTransferRequestV2: CreateTransferRequest, xImxEthAddress: kotlin.String?, xImxEthSignature: kotlin.String?) : CreateTransferResponse {
        val localVariableConfig = createTransferRequestConfig(createTransferRequestV2 = createTransferRequestV2, xImxEthAddress = xImxEthAddress, xImxEthSignature = xImxEthSignature)

        val localVarResponse = request<CreateTransferRequest, CreateTransferResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateTransferResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation createTransfer
    *
    * @param createTransferRequestV2 Create transfer 
    * @param xImxEthAddress eth address (optional)
    * @param xImxEthSignature eth signature (optional)
    * @return RequestConfig
    */
    fun createTransferRequestConfig(createTransferRequestV2: CreateTransferRequest, xImxEthAddress: kotlin.String?, xImxEthSignature: kotlin.String?) : RequestConfig<CreateTransferRequest> {
        val localVariableBody = createTransferRequestV2
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xImxEthAddress?.apply { localVariableHeaders["x-imx-eth-address"] = this.toString() }
        xImxEthSignature?.apply { localVariableHeaders["x-imx-eth-signature"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/transfers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Creates a transfer of tokens between two parties
    * Create a new transfer request
    * @param createTransferRequest Create transfer 
    * @param xImxEthAddress eth address (optional)
    * @param xImxEthSignature eth signature (optional)
    * @return CreateTransferResponseV1
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createTransferV1(createTransferRequest: CreateTransferRequestV1, xImxEthAddress: kotlin.String?, xImxEthSignature: kotlin.String?) : CreateTransferResponseV1 {
        val localVariableConfig = createTransferV1RequestConfig(createTransferRequest = createTransferRequest, xImxEthAddress = xImxEthAddress, xImxEthSignature = xImxEthSignature)

        val localVarResponse = request<CreateTransferRequestV1, CreateTransferResponseV1>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateTransferResponseV1
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation createTransferV1
    *
    * @param createTransferRequest Create transfer 
    * @param xImxEthAddress eth address (optional)
    * @param xImxEthSignature eth signature (optional)
    * @return RequestConfig
    */
    fun createTransferV1RequestConfig(createTransferRequest: CreateTransferRequestV1, xImxEthAddress: kotlin.String?, xImxEthSignature: kotlin.String?) : RequestConfig<CreateTransferRequestV1> {
        val localVariableBody = createTransferRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xImxEthAddress?.apply { localVariableHeaders["x-imx-eth-address"] = this.toString() }
        xImxEthSignature?.apply { localVariableHeaders["x-imx-eth-signature"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/transfers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Creates a withdrawal of a token
    * Creates a withdrawal
    * @param createWithdrawalRequest create a withdrawal 
    * @param xImxEthAddress eth address (optional)
    * @param xImxEthSignature eth signature (optional)
    * @return CreateWithdrawalResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createWithdrawal(createWithdrawalRequest: CreateWithdrawalRequest, xImxEthAddress: kotlin.String?, xImxEthSignature: kotlin.String?) : CreateWithdrawalResponse {
        val localVariableConfig = createWithdrawalRequestConfig(createWithdrawalRequest = createWithdrawalRequest, xImxEthAddress = xImxEthAddress, xImxEthSignature = xImxEthSignature)

        val localVarResponse = request<CreateWithdrawalRequest, CreateWithdrawalResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateWithdrawalResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation createWithdrawal
    *
    * @param createWithdrawalRequest create a withdrawal 
    * @param xImxEthAddress eth address (optional)
    * @param xImxEthSignature eth signature (optional)
    * @return RequestConfig
    */
    fun createWithdrawalRequestConfig(createWithdrawalRequest: CreateWithdrawalRequest, xImxEthAddress: kotlin.String?, xImxEthSignature: kotlin.String?) : RequestConfig<CreateWithdrawalRequest> {
        val localVariableBody = createWithdrawalRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xImxEthAddress?.apply { localVariableHeaders["x-imx-eth-address"] = this.toString() }
        xImxEthSignature?.apply { localVariableHeaders["x-imx-eth-signature"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/withdrawals",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get details of an asset
    * Get details of an asset
    * @param tokenAddress Address of the ERC721 contract 
    * @param tokenId Either ERC721 token ID or internal IMX ID 
    * @param includeFees Set flag to include fees associated with the asset (optional)
    * @return Asset
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAsset(tokenAddress: kotlin.String, tokenId: kotlin.String, includeFees: kotlin.Boolean?) : Asset {
        val localVariableConfig = getAssetRequestConfig(tokenAddress = tokenAddress, tokenId = tokenId, includeFees = includeFees)

        val localVarResponse = request<Unit, Asset>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Asset
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getAsset
    *
    * @param tokenAddress Address of the ERC721 contract 
    * @param tokenId Either ERC721 token ID or internal IMX ID 
    * @param includeFees Set flag to include fees associated with the asset (optional)
    * @return RequestConfig
    */
    fun getAssetRequestConfig(tokenAddress: kotlin.String, tokenId: kotlin.String, includeFees: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (includeFees != null) {
                    put("include_fees", listOf(includeFees.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/assets/{token_address}/{token_id}".replace("{"+"token_address"+"}", "$tokenAddress").replace("{"+"token_id"+"}", "$tokenId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Fetches the token balances of the user
    * Fetches the token balances of the user
    * @param owner Address of the owner/user 
    * @param address Token address 
    * @return GetBalanceResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBalance(owner: kotlin.String, address: kotlin.String) : GetBalanceResponse {
        val localVariableConfig = getBalanceRequestConfig(owner = owner, address = address)

        val localVarResponse = request<Unit, GetBalanceResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBalanceResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getBalance
    *
    * @param owner Address of the owner/user 
    * @param address Token address 
    * @return RequestConfig
    */
    fun getBalanceRequestConfig(owner: kotlin.String, address: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/balances/{owner}/{address}".replace("{"+"owner"+"}", "$owner").replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get details of a collection at the given address
    * Get details of a collection at the given address
    * @param address Collection contract address 
    * @return Collection
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCollection(address: kotlin.String) : Collection {
        val localVariableConfig = getCollectionRequestConfig(address = address)

        val localVarResponse = request<Unit, Collection>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Collection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getCollection
    *
    * @param address Collection contract address 
    * @return RequestConfig
    */
    fun getCollectionRequestConfig(address: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/collections/{address}".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get details of a deposit with the given ID
    * Get details of a deposit with the given ID
    * @param id Deposit ID 
    * @return Deposit
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getDeposit(id: kotlin.String) : Deposit {
        val localVariableConfig = getDepositRequestConfig(id = id)

        val localVarResponse = request<Unit, Deposit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Deposit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getDeposit
    *
    * @param id Deposit ID 
    * @return RequestConfig
    */
    fun getDepositRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/deposits/{id}".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get collection metadata schema
    * Get collection metadata schema
    * @param address Collection contract address 
    * @return kotlin.collections.List<MetadataSchemaProperty>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMetadataSchema(address: kotlin.String) : kotlin.collections.List<MetadataSchemaProperty> {
        val localVariableConfig = getMetadataSchemaRequestConfig(address = address)

        val localVarResponse = request<Unit, kotlin.collections.List<MetadataSchemaProperty>>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<MetadataSchemaProperty>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getMetadataSchema
    *
    * @param address Collection contract address 
    * @return RequestConfig
    */
    fun getMetadataSchemaRequestConfig(address: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/collections/{address}/metadata-schema".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get details of a mint with the given ID
    * Get details of a mint with the given ID
    * @param id Mint ID. This is the transaction_id returned from listMints 
    * @return Mint
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMint(id: kotlin.String) : Mint {
        val localVariableConfig = getMintRequestConfig(id = id)

        val localVarResponse = request<Unit, Mint>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Mint
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getMint
    *
    * @param id Mint ID. This is the transaction_id returned from listMints 
    * @return RequestConfig
    */
    fun getMintRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/mints/{id}".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get details of a mintable token with the given token address and token ID
    * Get details of a mintable token with the given token address and token ID
    * @param tokenAddress Address of the ERC721 contract 
    * @param tokenId ERC721 token ID 
    * @return MintableTokenDetails
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMintableTokenDetailsByClientTokenId(tokenAddress: kotlin.String, tokenId: kotlin.String) : MintableTokenDetails {
        val localVariableConfig = getMintableTokenDetailsByClientTokenIdRequestConfig(tokenAddress = tokenAddress, tokenId = tokenId)

        val localVarResponse = request<Unit, MintableTokenDetails>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MintableTokenDetails
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getMintableTokenDetailsByClientTokenId
    *
    * @param tokenAddress Address of the ERC721 contract 
    * @param tokenId ERC721 token ID 
    * @return RequestConfig
    */
    fun getMintableTokenDetailsByClientTokenIdRequestConfig(tokenAddress: kotlin.String, tokenId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/mintable-token/{token_address}/{token_id}".replace("{"+"token_address"+"}", "$tokenAddress").replace("{"+"token_id"+"}", "$tokenId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get details of an order with the given ID
    * Get details of an order with the given ID
    * @param id Order ID 
    * @param includeFees Set flag to true to include fee body for the order (optional)
    * @param auxiliaryFeePercentages Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients (optional)
    * @param auxiliaryFeeRecipients Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages (optional)
    * @return Order
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOrder(id: kotlin.String, includeFees: kotlin.Boolean?, auxiliaryFeePercentages: kotlin.String?, auxiliaryFeeRecipients: kotlin.String?) : Order {
        val localVariableConfig = getOrderRequestConfig(id = id, includeFees = includeFees, auxiliaryFeePercentages = auxiliaryFeePercentages, auxiliaryFeeRecipients = auxiliaryFeeRecipients)

        val localVarResponse = request<Unit, Order>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Order
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getOrder
    *
    * @param id Order ID 
    * @param includeFees Set flag to true to include fee body for the order (optional)
    * @param auxiliaryFeePercentages Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients (optional)
    * @param auxiliaryFeeRecipients Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages (optional)
    * @return RequestConfig
    */
    fun getOrderRequestConfig(id: kotlin.String, includeFees: kotlin.Boolean?, auxiliaryFeePercentages: kotlin.String?, auxiliaryFeeRecipients: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (includeFees != null) {
                    put("include_fees", listOf(includeFees.toString()))
                }
                if (auxiliaryFeePercentages != null) {
                    put("auxiliary_fee_percentages", listOf(auxiliaryFeePercentages.toString()))
                }
                if (auxiliaryFeeRecipients != null) {
                    put("auxiliary_fee_recipients", listOf(auxiliaryFeeRecipients.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/orders/{id}".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a project
    * Get a project
    * @param id Project ID 
    * @param imXSignature String created by signing wallet address and timestamp 
    * @param imXTimestamp Unix Epoc timestamp 
    * @return Project
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getProject(id: kotlin.String, imXSignature: kotlin.String, imXTimestamp: kotlin.String) : Project {
        val localVariableConfig = getProjectRequestConfig(id = id, imXSignature = imXSignature, imXTimestamp = imXTimestamp)

        val localVarResponse = request<Unit, Project>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Project
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getProject
    *
    * @param id Project ID 
    * @param imXSignature String created by signing wallet address and timestamp 
    * @param imXTimestamp Unix Epoc timestamp 
    * @return RequestConfig
    */
    fun getProjectRequestConfig(id: kotlin.String, imXSignature: kotlin.String, imXTimestamp: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        imXSignature.apply { localVariableHeaders["IMX-Signature"] = this.toString() }
        imXTimestamp.apply { localVariableHeaders["IMX-Timestamp"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/projects/{id}".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get projects
    * Get projects
    * @param imXSignature String created by signing wallet address and timestamp 
    * @param imXTimestamp Unix Epoc timestamp 
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @return GetProjectsResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getProjects(imXSignature: kotlin.String, imXTimestamp: kotlin.String, pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?) : GetProjectsResponse {
        val localVariableConfig = getProjectsRequestConfig(imXSignature = imXSignature, imXTimestamp = imXTimestamp, pageSize = pageSize, cursor = cursor, orderBy = orderBy, direction = direction)

        val localVarResponse = request<Unit, GetProjectsResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetProjectsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getProjects
    *
    * @param imXSignature String created by signing wallet address and timestamp 
    * @param imXTimestamp Unix Epoc timestamp 
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @return RequestConfig
    */
    fun getProjectsRequestConfig(imXSignature: kotlin.String, imXTimestamp: kotlin.String, pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (orderBy != null) {
                    put("order_by", listOf(orderBy.toString()))
                }
                if (direction != null) {
                    put("direction", listOf(direction.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        imXSignature.apply { localVariableHeaders["IMX-Signature"] = this.toString() }
        imXTimestamp.apply { localVariableHeaders["IMX-Timestamp"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/projects",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get details a signable cancel order
    * Get details a signable cancel order
    * @param getSignableCancelOrderRequest get a signable cancel order 
    * @return GetSignableCancelOrderResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSignableCancelOrder(getSignableCancelOrderRequest: GetSignableCancelOrderRequest) : GetSignableCancelOrderResponse {
        val localVariableConfig = getSignableCancelOrderRequestConfig(getSignableCancelOrderRequest = getSignableCancelOrderRequest)

        val localVarResponse = request<GetSignableCancelOrderRequest, GetSignableCancelOrderResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetSignableCancelOrderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getSignableCancelOrder
    *
    * @param getSignableCancelOrderRequest get a signable cancel order 
    * @return RequestConfig
    */
    fun getSignableCancelOrderRequestConfig(getSignableCancelOrderRequest: GetSignableCancelOrderRequest) : RequestConfig<GetSignableCancelOrderRequest> {
        val localVariableBody = getSignableCancelOrderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/signable-cancel-order-details",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Gets details of a signable deposit
    * Gets details of a signable deposit
    * @param getSignableDepositRequest Get details of signable deposit 
    * @return GetSignableDepositResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSignableDeposit(getSignableDepositRequest: GetSignableDepositRequest) : GetSignableDepositResponse {
        val localVariableConfig = getSignableDepositRequestConfig(getSignableDepositRequest = getSignableDepositRequest)

        val localVarResponse = request<GetSignableDepositRequest, GetSignableDepositResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetSignableDepositResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getSignableDeposit
    *
    * @param getSignableDepositRequest Get details of signable deposit 
    * @return RequestConfig
    */
    fun getSignableDepositRequestConfig(getSignableDepositRequest: GetSignableDepositRequest) : RequestConfig<GetSignableDepositRequest> {
        val localVariableBody = getSignableDepositRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/signable-deposit-details",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get details a signable order V3
    * Get details a signable order V3
    * @param getSignableOrderRequestV3 get a signable order 
    * @return GetSignableOrderResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSignableOrder(getSignableOrderRequestV3: GetSignableOrderRequest) : GetSignableOrderResponse {
        val localVariableConfig = getSignableOrderRequestConfig(getSignableOrderRequestV3 = getSignableOrderRequestV3)

        val localVarResponse = request<GetSignableOrderRequest, GetSignableOrderResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetSignableOrderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getSignableOrder
    *
    * @param getSignableOrderRequestV3 get a signable order 
    * @return RequestConfig
    */
    fun getSignableOrderRequestConfig(getSignableOrderRequestV3: GetSignableOrderRequest) : RequestConfig<GetSignableOrderRequest> {
        val localVariableBody = getSignableOrderRequestV3
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v3/signable-order-details",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get operator signature to allow clients to register the user
    * Get operator signature to allow clients to register the user
    * @param getSignableRegistrationRequest Register User 
    * @return GetSignableRegistrationResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSignableRegistration(getSignableRegistrationRequest: GetSignableRegistrationRequest) : GetSignableRegistrationResponse {
        val localVariableConfig = getSignableRegistrationRequestConfig(getSignableRegistrationRequest = getSignableRegistrationRequest)

        val localVarResponse = request<GetSignableRegistrationRequest, GetSignableRegistrationResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetSignableRegistrationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getSignableRegistration
    *
    * @param getSignableRegistrationRequest Register User 
    * @return RequestConfig
    */
    fun getSignableRegistrationRequestConfig(getSignableRegistrationRequest: GetSignableRegistrationRequest) : RequestConfig<GetSignableRegistrationRequest> {
        val localVariableBody = getSignableRegistrationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/signable-registration",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get details a signable trade V3
    * Get details a signable trade V3
    * @param getSignableTradeRequest get a signable trade 
    * @return GetSignableTradeResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSignableTrade(getSignableTradeRequest: GetSignableTradeRequest) : GetSignableTradeResponse {
        val localVariableConfig = getSignableTradeRequestConfig(getSignableTradeRequest = getSignableTradeRequest)

        val localVarResponse = request<GetSignableTradeRequest, GetSignableTradeResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetSignableTradeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getSignableTrade
    *
    * @param getSignableTradeRequest get a signable trade 
    * @return RequestConfig
    */
    fun getSignableTradeRequestConfig(getSignableTradeRequest: GetSignableTradeRequest) : RequestConfig<GetSignableTradeRequest> {
        val localVariableBody = getSignableTradeRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v3/signable-trade-details",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Gets bulk details of a signable transfer
    * Gets bulk details of a signable transfer
    * @param getSignableTransferRequestV2 get details of signable transfer 
    * @return GetSignableTransferResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSignableTransfer(getSignableTransferRequestV2: GetSignableTransferRequest) : GetSignableTransferResponse {
        val localVariableConfig = getSignableTransferRequestConfig(getSignableTransferRequestV2 = getSignableTransferRequestV2)

        val localVarResponse = request<GetSignableTransferRequest, GetSignableTransferResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetSignableTransferResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getSignableTransfer
    *
    * @param getSignableTransferRequestV2 get details of signable transfer 
    * @return RequestConfig
    */
    fun getSignableTransferRequestConfig(getSignableTransferRequestV2: GetSignableTransferRequest) : RequestConfig<GetSignableTransferRequest> {
        val localVariableBody = getSignableTransferRequestV2
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/signable-transfer-details",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Gets details of a signable transfer
    * Gets details of a signable transfer
    * @param getSignableTransferRequest get details of signable transfer 
    * @return GetSignableTransferResponseV1
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSignableTransferV1(getSignableTransferRequest: GetSignableTransferRequestV1) : GetSignableTransferResponseV1 {
        val localVariableConfig = getSignableTransferV1RequestConfig(getSignableTransferRequest = getSignableTransferRequest)

        val localVarResponse = request<GetSignableTransferRequestV1, GetSignableTransferResponseV1>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetSignableTransferResponseV1
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getSignableTransferV1
    *
    * @param getSignableTransferRequest get details of signable transfer 
    * @return RequestConfig
    */
    fun getSignableTransferV1RequestConfig(getSignableTransferRequest: GetSignableTransferRequestV1) : RequestConfig<GetSignableTransferRequestV1> {
        val localVariableBody = getSignableTransferRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/signable-transfer-details",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Gets details of a signable withdrawal
    * Gets details of a signable withdrawal
    * @param getSignableWithdrawalRequest get details of signable withdrawal 
    * @return GetSignableWithdrawalResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSignableWithdrawal(getSignableWithdrawalRequest: GetSignableWithdrawalRequest) : GetSignableWithdrawalResponse {
        val localVariableConfig = getSignableWithdrawalRequestConfig(getSignableWithdrawalRequest = getSignableWithdrawalRequest)

        val localVarResponse = request<GetSignableWithdrawalRequest, GetSignableWithdrawalResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetSignableWithdrawalResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getSignableWithdrawal
    *
    * @param getSignableWithdrawalRequest get details of signable withdrawal 
    * @return RequestConfig
    */
    fun getSignableWithdrawalRequestConfig(getSignableWithdrawalRequest: GetSignableWithdrawalRequest) : RequestConfig<GetSignableWithdrawalRequest> {
        val localVariableBody = getSignableWithdrawalRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/signable-withdrawal-details",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get details of a token
    * Get details of a token
    * @param address Token Contract Address 
    * @return TokenDetails
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getToken(address: kotlin.String) : TokenDetails {
        val localVariableConfig = getTokenRequestConfig(address = address)

        val localVarResponse = request<Unit, TokenDetails>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TokenDetails
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getToken
    *
    * @param address Token Contract Address 
    * @return RequestConfig
    */
    fun getTokenRequestConfig(address: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/tokens/{address}".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get details of a trade with the given ID
    * Get details of a trade with the given ID
    * @param id Trade ID 
    * @return Trade
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTrade(id: kotlin.String) : Trade {
        val localVariableConfig = getTradeRequestConfig(id = id)

        val localVarResponse = request<Unit, Trade>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Trade
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getTrade
    *
    * @param id Trade ID 
    * @return RequestConfig
    */
    fun getTradeRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/trades/{id}".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get details of a transfer with the given ID
    * Get details of a transfer with the given ID
    * @param id Transfer ID 
    * @return Transfer
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTransfer(id: kotlin.String) : Transfer {
        val localVariableConfig = getTransferRequestConfig(id = id)

        val localVarResponse = request<Unit, Transfer>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Transfer
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getTransfer
    *
    * @param id Transfer ID 
    * @return RequestConfig
    */
    fun getTransferRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/transfers/{id}".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get stark keys for a registered user
    * Get stark keys for a registered user
    * @param user User 
    * @return GetUsersApiResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getUsers(user: kotlin.String) : GetUsersApiResponse {
        val localVariableConfig = getUsersRequestConfig(user = user)

        val localVarResponse = request<Unit, GetUsersApiResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetUsersApiResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getUsers
    *
    * @param user User 
    * @return RequestConfig
    */
    fun getUsersRequestConfig(user: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/users/{user}".replace("{"+"user"+"}", "$user"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Gets details of withdrawal with the given ID
    * Gets details of withdrawal with the given ID
    * @param id Withdrawal ID 
    * @return Withdrawal
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getWithdrawal(id: kotlin.String) : Withdrawal {
        val localVariableConfig = getWithdrawalRequestConfig(id = id)

        val localVarResponse = request<Unit, Withdrawal>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Withdrawal
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getWithdrawal
    *
    * @param id Withdrawal ID 
    * @return RequestConfig
    */
    fun getWithdrawalRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/withdrawals/{id}".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a list of assets
    * Get a list of assets
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param user Ethereum address of the user who owns these assets (optional)
    * @param status Status of these assets (optional)
    * @param name Name of the asset to search (optional)
    * @param metadata JSON-encoded metadata filters for these asset. Example: { (optional)
    * @param sellOrders Set flag to true to fetch an array of sell order details with accepted status associated with the asset (optional)
    * @param buyOrders Set flag to true to fetch an array of buy order details  with accepted status associated with the asset (optional)
    * @param includeFees Set flag to include fees associated with the asset (optional)
    * @param collection Collection contract address (optional)
    * @param updatedMinTimestamp Minimum timestamp for when these assets were last updated (optional)
    * @param updatedMaxTimestamp Maximum timestamp for when these assets were last updated (optional)
    * @param auxiliaryFeePercentages Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients (optional)
    * @param auxiliaryFeeRecipients Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages (optional)
    * @return ListAssetsResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listAssets(pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, user: kotlin.String?, status: kotlin.String?, name: kotlin.String?, metadata: kotlin.String?, sellOrders: kotlin.Boolean?, buyOrders: kotlin.Boolean?, includeFees: kotlin.Boolean?, collection: kotlin.String?, updatedMinTimestamp: kotlin.String?, updatedMaxTimestamp: kotlin.String?, auxiliaryFeePercentages: kotlin.String?, auxiliaryFeeRecipients: kotlin.String?) : ListAssetsResponse {
        val localVariableConfig = listAssetsRequestConfig(pageSize = pageSize, cursor = cursor, orderBy = orderBy, direction = direction, user = user, status = status, name = name, metadata = metadata, sellOrders = sellOrders, buyOrders = buyOrders, includeFees = includeFees, collection = collection, updatedMinTimestamp = updatedMinTimestamp, updatedMaxTimestamp = updatedMaxTimestamp, auxiliaryFeePercentages = auxiliaryFeePercentages, auxiliaryFeeRecipients = auxiliaryFeeRecipients)

        val localVarResponse = request<Unit, ListAssetsResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListAssetsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation listAssets
    *
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param user Ethereum address of the user who owns these assets (optional)
    * @param status Status of these assets (optional)
    * @param name Name of the asset to search (optional)
    * @param metadata JSON-encoded metadata filters for these asset. Example: { (optional)
    * @param sellOrders Set flag to true to fetch an array of sell order details with accepted status associated with the asset (optional)
    * @param buyOrders Set flag to true to fetch an array of buy order details  with accepted status associated with the asset (optional)
    * @param includeFees Set flag to include fees associated with the asset (optional)
    * @param collection Collection contract address (optional)
    * @param updatedMinTimestamp Minimum timestamp for when these assets were last updated (optional)
    * @param updatedMaxTimestamp Maximum timestamp for when these assets were last updated (optional)
    * @param auxiliaryFeePercentages Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients (optional)
    * @param auxiliaryFeeRecipients Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages (optional)
    * @return RequestConfig
    */
    fun listAssetsRequestConfig(pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, user: kotlin.String?, status: kotlin.String?, name: kotlin.String?, metadata: kotlin.String?, sellOrders: kotlin.Boolean?, buyOrders: kotlin.Boolean?, includeFees: kotlin.Boolean?, collection: kotlin.String?, updatedMinTimestamp: kotlin.String?, updatedMaxTimestamp: kotlin.String?, auxiliaryFeePercentages: kotlin.String?, auxiliaryFeeRecipients: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (orderBy != null) {
                    put("order_by", listOf(orderBy.toString()))
                }
                if (direction != null) {
                    put("direction", listOf(direction.toString()))
                }
                if (user != null) {
                    put("user", listOf(user.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (metadata != null) {
                    put("metadata", listOf(metadata.toString()))
                }
                if (sellOrders != null) {
                    put("sell_orders", listOf(sellOrders.toString()))
                }
                if (buyOrders != null) {
                    put("buy_orders", listOf(buyOrders.toString()))
                }
                if (includeFees != null) {
                    put("include_fees", listOf(includeFees.toString()))
                }
                if (collection != null) {
                    put("collection", listOf(collection.toString()))
                }
                if (updatedMinTimestamp != null) {
                    put("updated_min_timestamp", listOf(updatedMinTimestamp.toString()))
                }
                if (updatedMaxTimestamp != null) {
                    put("updated_max_timestamp", listOf(updatedMaxTimestamp.toString()))
                }
                if (auxiliaryFeePercentages != null) {
                    put("auxiliary_fee_percentages", listOf(auxiliaryFeePercentages.toString()))
                }
                if (auxiliaryFeeRecipients != null) {
                    put("auxiliary_fee_recipients", listOf(auxiliaryFeeRecipients.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/assets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a list of balances for given user
    * Get a list of balances for given user
    * @param owner Ethereum wallet address for user 
    * @return ListBalancesResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listBalances(owner: kotlin.String) : ListBalancesResponse {
        val localVariableConfig = listBalancesRequestConfig(owner = owner)

        val localVarResponse = request<Unit, ListBalancesResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListBalancesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation listBalances
    *
    * @param owner Ethereum wallet address for user 
    * @return RequestConfig
    */
    fun listBalancesRequestConfig(owner: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/balances/{owner}".replace("{"+"owner"+"}", "$owner"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a list of collection filters
    * Get a list of collection filters
    * @param address Collection contract address 
    * @param pageSize Page size of the result (optional)
    * @param nextPageToken Next page token (optional)
    * @return CollectionFilter
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listCollectionFilters(address: kotlin.String, pageSize: kotlin.Int?, nextPageToken: kotlin.String?) : CollectionFilter {
        val localVariableConfig = listCollectionFiltersRequestConfig(address = address, pageSize = pageSize, nextPageToken = nextPageToken)

        val localVarResponse = request<Unit, CollectionFilter>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CollectionFilter
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation listCollectionFilters
    *
    * @param address Collection contract address 
    * @param pageSize Page size of the result (optional)
    * @param nextPageToken Next page token (optional)
    * @return RequestConfig
    */
    fun listCollectionFiltersRequestConfig(address: kotlin.String, pageSize: kotlin.Int?, nextPageToken: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (nextPageToken != null) {
                    put("next_page_token", listOf(nextPageToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/collections/{address}/filters".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a list of collections
    * Get a list of collections
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param blacklist List of collections not to be displayed, separated by commas (optional)
    * @return ListCollectionsResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listCollections(pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, blacklist: kotlin.String?) : ListCollectionsResponse {
        val localVariableConfig = listCollectionsRequestConfig(pageSize = pageSize, cursor = cursor, orderBy = orderBy, direction = direction, blacklist = blacklist)

        val localVarResponse = request<Unit, ListCollectionsResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListCollectionsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation listCollections
    *
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param blacklist List of collections not to be displayed, separated by commas (optional)
    * @return RequestConfig
    */
    fun listCollectionsRequestConfig(pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, blacklist: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (orderBy != null) {
                    put("order_by", listOf(orderBy.toString()))
                }
                if (direction != null) {
                    put("direction", listOf(direction.toString()))
                }
                if (blacklist != null) {
                    put("blacklist", listOf(blacklist.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/collections",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a list of deposits
    * Get a list of deposits
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param user Ethereum address of the user who submitted this deposit (optional)
    * @param status Status of this deposit (optional)
    * @param minTimestamp Minimum timestamp for this deposit (optional)
    * @param maxTimestamp Maximum timestamp for this deposit (optional)
    * @param tokenType Token type of the deposited asset (optional)
    * @param tokenId ERC721 Token ID of the minted asset (optional)
    * @param assetId Internal IMX ID of the minted asset (optional)
    * @param tokenAddress Token address of the deposited asset (optional)
    * @param tokenName Token name of the deposited asset (optional)
    * @param minQuantity Min quantity for the deposited asset (optional)
    * @param maxQuantity Max quantity for the deposited asset (optional)
    * @param metadata JSON-encoded metadata filters for the deposited asset (optional)
    * @return ListDepositsResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listDeposits(pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, user: kotlin.String?, status: kotlin.String?, minTimestamp: kotlin.String?, maxTimestamp: kotlin.String?, tokenType: kotlin.String?, tokenId: kotlin.String?, assetId: kotlin.String?, tokenAddress: kotlin.String?, tokenName: kotlin.String?, minQuantity: kotlin.String?, maxQuantity: kotlin.String?, metadata: kotlin.String?) : ListDepositsResponse {
        val localVariableConfig = listDepositsRequestConfig(pageSize = pageSize, cursor = cursor, orderBy = orderBy, direction = direction, user = user, status = status, minTimestamp = minTimestamp, maxTimestamp = maxTimestamp, tokenType = tokenType, tokenId = tokenId, assetId = assetId, tokenAddress = tokenAddress, tokenName = tokenName, minQuantity = minQuantity, maxQuantity = maxQuantity, metadata = metadata)

        val localVarResponse = request<Unit, ListDepositsResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListDepositsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation listDeposits
    *
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param user Ethereum address of the user who submitted this deposit (optional)
    * @param status Status of this deposit (optional)
    * @param minTimestamp Minimum timestamp for this deposit (optional)
    * @param maxTimestamp Maximum timestamp for this deposit (optional)
    * @param tokenType Token type of the deposited asset (optional)
    * @param tokenId ERC721 Token ID of the minted asset (optional)
    * @param assetId Internal IMX ID of the minted asset (optional)
    * @param tokenAddress Token address of the deposited asset (optional)
    * @param tokenName Token name of the deposited asset (optional)
    * @param minQuantity Min quantity for the deposited asset (optional)
    * @param maxQuantity Max quantity for the deposited asset (optional)
    * @param metadata JSON-encoded metadata filters for the deposited asset (optional)
    * @return RequestConfig
    */
    fun listDepositsRequestConfig(pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, user: kotlin.String?, status: kotlin.String?, minTimestamp: kotlin.String?, maxTimestamp: kotlin.String?, tokenType: kotlin.String?, tokenId: kotlin.String?, assetId: kotlin.String?, tokenAddress: kotlin.String?, tokenName: kotlin.String?, minQuantity: kotlin.String?, maxQuantity: kotlin.String?, metadata: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (orderBy != null) {
                    put("order_by", listOf(orderBy.toString()))
                }
                if (direction != null) {
                    put("direction", listOf(direction.toString()))
                }
                if (user != null) {
                    put("user", listOf(user.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (minTimestamp != null) {
                    put("min_timestamp", listOf(minTimestamp.toString()))
                }
                if (maxTimestamp != null) {
                    put("max_timestamp", listOf(maxTimestamp.toString()))
                }
                if (tokenType != null) {
                    put("token_type", listOf(tokenType.toString()))
                }
                if (tokenId != null) {
                    put("token_id", listOf(tokenId.toString()))
                }
                if (assetId != null) {
                    put("asset_id", listOf(assetId.toString()))
                }
                if (tokenAddress != null) {
                    put("token_address", listOf(tokenAddress.toString()))
                }
                if (tokenName != null) {
                    put("token_name", listOf(tokenName.toString()))
                }
                if (minQuantity != null) {
                    put("min_quantity", listOf(minQuantity.toString()))
                }
                if (maxQuantity != null) {
                    put("max_quantity", listOf(maxQuantity.toString()))
                }
                if (metadata != null) {
                    put("metadata", listOf(metadata.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/deposits",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a list of mints
    * Get a list of mints
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param user Ethereum address of the user who submitted this mint (optional)
    * @param status Status of this mint (optional)
    * @param minTimestamp Minimum timestamp for this mint (optional)
    * @param maxTimestamp Maximum timestamp for this mint (optional)
    * @param tokenType Token type of the minted asset (optional)
    * @param tokenId ERC721 Token ID of the minted asset (optional)
    * @param assetId Internal IMX ID of the minted asset (optional)
    * @param tokenName Token Name of the minted asset (optional)
    * @param tokenAddress Token address of the minted asset (optional)
    * @param minQuantity Min quantity for the minted asset (optional)
    * @param maxQuantity Max quantity for the minted asset (optional)
    * @param metadata JSON-encoded metadata filters for the minted asset (optional)
    * @return ListMintsResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listMints(pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, user: kotlin.String?, status: kotlin.String?, minTimestamp: kotlin.String?, maxTimestamp: kotlin.String?, tokenType: kotlin.String?, tokenId: kotlin.String?, assetId: kotlin.String?, tokenName: kotlin.String?, tokenAddress: kotlin.String?, minQuantity: kotlin.String?, maxQuantity: kotlin.String?, metadata: kotlin.String?) : ListMintsResponse {
        val localVariableConfig = listMintsRequestConfig(pageSize = pageSize, cursor = cursor, orderBy = orderBy, direction = direction, user = user, status = status, minTimestamp = minTimestamp, maxTimestamp = maxTimestamp, tokenType = tokenType, tokenId = tokenId, assetId = assetId, tokenName = tokenName, tokenAddress = tokenAddress, minQuantity = minQuantity, maxQuantity = maxQuantity, metadata = metadata)

        val localVarResponse = request<Unit, ListMintsResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListMintsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation listMints
    *
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param user Ethereum address of the user who submitted this mint (optional)
    * @param status Status of this mint (optional)
    * @param minTimestamp Minimum timestamp for this mint (optional)
    * @param maxTimestamp Maximum timestamp for this mint (optional)
    * @param tokenType Token type of the minted asset (optional)
    * @param tokenId ERC721 Token ID of the minted asset (optional)
    * @param assetId Internal IMX ID of the minted asset (optional)
    * @param tokenName Token Name of the minted asset (optional)
    * @param tokenAddress Token address of the minted asset (optional)
    * @param minQuantity Min quantity for the minted asset (optional)
    * @param maxQuantity Max quantity for the minted asset (optional)
    * @param metadata JSON-encoded metadata filters for the minted asset (optional)
    * @return RequestConfig
    */
    fun listMintsRequestConfig(pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, user: kotlin.String?, status: kotlin.String?, minTimestamp: kotlin.String?, maxTimestamp: kotlin.String?, tokenType: kotlin.String?, tokenId: kotlin.String?, assetId: kotlin.String?, tokenName: kotlin.String?, tokenAddress: kotlin.String?, minQuantity: kotlin.String?, maxQuantity: kotlin.String?, metadata: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (orderBy != null) {
                    put("order_by", listOf(orderBy.toString()))
                }
                if (direction != null) {
                    put("direction", listOf(direction.toString()))
                }
                if (user != null) {
                    put("user", listOf(user.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (minTimestamp != null) {
                    put("min_timestamp", listOf(minTimestamp.toString()))
                }
                if (maxTimestamp != null) {
                    put("max_timestamp", listOf(maxTimestamp.toString()))
                }
                if (tokenType != null) {
                    put("token_type", listOf(tokenType.toString()))
                }
                if (tokenId != null) {
                    put("token_id", listOf(tokenId.toString()))
                }
                if (assetId != null) {
                    put("asset_id", listOf(assetId.toString()))
                }
                if (tokenName != null) {
                    put("token_name", listOf(tokenName.toString()))
                }
                if (tokenAddress != null) {
                    put("token_address", listOf(tokenAddress.toString()))
                }
                if (minQuantity != null) {
                    put("min_quantity", listOf(minQuantity.toString()))
                }
                if (maxQuantity != null) {
                    put("max_quantity", listOf(maxQuantity.toString()))
                }
                if (metadata != null) {
                    put("metadata", listOf(metadata.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/mints",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a list of orders
    * Get a list of orders
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param user Ethereum address of the user who submitted this order (optional)
    * @param status Status of this order (optional)
    * @param minTimestamp Minimum created at timestamp for this order (optional)
    * @param maxTimestamp Maximum created at timestamp for this order (optional)
    * @param updatedMinTimestamp Minimum updated at timestamp for this order (optional)
    * @param updatedMaxTimestamp Maximum updated at timestamp for this order (optional)
    * @param buyTokenType Token type of the asset this order buys (optional)
    * @param buyTokenId ERC721 Token ID of the asset this order buys (optional)
    * @param buyAssetId Internal IMX ID of the asset this order buys (optional)
    * @param buyTokenAddress Comma separated string of token addresses of the asset this order buys (optional)
    * @param buyTokenName Token name of the asset this order buys (optional)
    * @param buyMinQuantity Min quantity for the asset this order buys (optional)
    * @param buyMaxQuantity Max quantity for the asset this order buys (optional)
    * @param buyMetadata JSON-encoded metadata filters for the asset this order buys (optional)
    * @param sellTokenType Token type of the asset this order sells (optional)
    * @param sellTokenId ERC721 Token ID of the asset this order sells (optional)
    * @param sellAssetId Internal IMX ID of the asset this order sells (optional)
    * @param sellTokenAddress Comma separated string of token addresses of the asset this order sells (optional)
    * @param sellTokenName Token name of the asset this order sells (optional)
    * @param sellMinQuantity Min quantity for the asset this order sells (optional)
    * @param sellMaxQuantity Max quantity for the asset this order sells (optional)
    * @param sellMetadata JSON-encoded metadata filters for the asset this order sells (optional)
    * @param auxiliaryFeePercentages Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients (optional)
    * @param auxiliaryFeeRecipients Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages (optional)
    * @return ListOrdersResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listOrders(pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, user: kotlin.String?, status: kotlin.String?, minTimestamp: kotlin.String?, maxTimestamp: kotlin.String?, updatedMinTimestamp: kotlin.String?, updatedMaxTimestamp: kotlin.String?, buyTokenType: kotlin.String?, buyTokenId: kotlin.String?, buyAssetId: kotlin.String?, buyTokenAddress: kotlin.String?, buyTokenName: kotlin.String?, buyMinQuantity: kotlin.String?, buyMaxQuantity: kotlin.String?, buyMetadata: kotlin.String?, sellTokenType: kotlin.String?, sellTokenId: kotlin.String?, sellAssetId: kotlin.String?, sellTokenAddress: kotlin.String?, sellTokenName: kotlin.String?, sellMinQuantity: kotlin.String?, sellMaxQuantity: kotlin.String?, sellMetadata: kotlin.String?, auxiliaryFeePercentages: kotlin.String?, auxiliaryFeeRecipients: kotlin.String?) : ListOrdersResponse {
        val localVariableConfig = listOrdersRequestConfig(pageSize = pageSize, cursor = cursor, orderBy = orderBy, direction = direction, user = user, status = status, minTimestamp = minTimestamp, maxTimestamp = maxTimestamp, updatedMinTimestamp = updatedMinTimestamp, updatedMaxTimestamp = updatedMaxTimestamp, buyTokenType = buyTokenType, buyTokenId = buyTokenId, buyAssetId = buyAssetId, buyTokenAddress = buyTokenAddress, buyTokenName = buyTokenName, buyMinQuantity = buyMinQuantity, buyMaxQuantity = buyMaxQuantity, buyMetadata = buyMetadata, sellTokenType = sellTokenType, sellTokenId = sellTokenId, sellAssetId = sellAssetId, sellTokenAddress = sellTokenAddress, sellTokenName = sellTokenName, sellMinQuantity = sellMinQuantity, sellMaxQuantity = sellMaxQuantity, sellMetadata = sellMetadata, auxiliaryFeePercentages = auxiliaryFeePercentages, auxiliaryFeeRecipients = auxiliaryFeeRecipients)

        val localVarResponse = request<Unit, ListOrdersResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListOrdersResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation listOrders
    *
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param user Ethereum address of the user who submitted this order (optional)
    * @param status Status of this order (optional)
    * @param minTimestamp Minimum created at timestamp for this order (optional)
    * @param maxTimestamp Maximum created at timestamp for this order (optional)
    * @param updatedMinTimestamp Minimum updated at timestamp for this order (optional)
    * @param updatedMaxTimestamp Maximum updated at timestamp for this order (optional)
    * @param buyTokenType Token type of the asset this order buys (optional)
    * @param buyTokenId ERC721 Token ID of the asset this order buys (optional)
    * @param buyAssetId Internal IMX ID of the asset this order buys (optional)
    * @param buyTokenAddress Comma separated string of token addresses of the asset this order buys (optional)
    * @param buyTokenName Token name of the asset this order buys (optional)
    * @param buyMinQuantity Min quantity for the asset this order buys (optional)
    * @param buyMaxQuantity Max quantity for the asset this order buys (optional)
    * @param buyMetadata JSON-encoded metadata filters for the asset this order buys (optional)
    * @param sellTokenType Token type of the asset this order sells (optional)
    * @param sellTokenId ERC721 Token ID of the asset this order sells (optional)
    * @param sellAssetId Internal IMX ID of the asset this order sells (optional)
    * @param sellTokenAddress Comma separated string of token addresses of the asset this order sells (optional)
    * @param sellTokenName Token name of the asset this order sells (optional)
    * @param sellMinQuantity Min quantity for the asset this order sells (optional)
    * @param sellMaxQuantity Max quantity for the asset this order sells (optional)
    * @param sellMetadata JSON-encoded metadata filters for the asset this order sells (optional)
    * @param auxiliaryFeePercentages Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients (optional)
    * @param auxiliaryFeeRecipients Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages (optional)
    * @return RequestConfig
    */
    fun listOrdersRequestConfig(pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, user: kotlin.String?, status: kotlin.String?, minTimestamp: kotlin.String?, maxTimestamp: kotlin.String?, updatedMinTimestamp: kotlin.String?, updatedMaxTimestamp: kotlin.String?, buyTokenType: kotlin.String?, buyTokenId: kotlin.String?, buyAssetId: kotlin.String?, buyTokenAddress: kotlin.String?, buyTokenName: kotlin.String?, buyMinQuantity: kotlin.String?, buyMaxQuantity: kotlin.String?, buyMetadata: kotlin.String?, sellTokenType: kotlin.String?, sellTokenId: kotlin.String?, sellAssetId: kotlin.String?, sellTokenAddress: kotlin.String?, sellTokenName: kotlin.String?, sellMinQuantity: kotlin.String?, sellMaxQuantity: kotlin.String?, sellMetadata: kotlin.String?, auxiliaryFeePercentages: kotlin.String?, auxiliaryFeeRecipients: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (orderBy != null) {
                    put("order_by", listOf(orderBy.toString()))
                }
                if (direction != null) {
                    put("direction", listOf(direction.toString()))
                }
                if (user != null) {
                    put("user", listOf(user.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (minTimestamp != null) {
                    put("min_timestamp", listOf(minTimestamp.toString()))
                }
                if (maxTimestamp != null) {
                    put("max_timestamp", listOf(maxTimestamp.toString()))
                }
                if (updatedMinTimestamp != null) {
                    put("updated_min_timestamp", listOf(updatedMinTimestamp.toString()))
                }
                if (updatedMaxTimestamp != null) {
                    put("updated_max_timestamp", listOf(updatedMaxTimestamp.toString()))
                }
                if (buyTokenType != null) {
                    put("buy_token_type", listOf(buyTokenType.toString()))
                }
                if (buyTokenId != null) {
                    put("buy_token_id", listOf(buyTokenId.toString()))
                }
                if (buyAssetId != null) {
                    put("buy_asset_id", listOf(buyAssetId.toString()))
                }
                if (buyTokenAddress != null) {
                    put("buy_token_address", listOf(buyTokenAddress.toString()))
                }
                if (buyTokenName != null) {
                    put("buy_token_name", listOf(buyTokenName.toString()))
                }
                if (buyMinQuantity != null) {
                    put("buy_min_quantity", listOf(buyMinQuantity.toString()))
                }
                if (buyMaxQuantity != null) {
                    put("buy_max_quantity", listOf(buyMaxQuantity.toString()))
                }
                if (buyMetadata != null) {
                    put("buy_metadata", listOf(buyMetadata.toString()))
                }
                if (sellTokenType != null) {
                    put("sell_token_type", listOf(sellTokenType.toString()))
                }
                if (sellTokenId != null) {
                    put("sell_token_id", listOf(sellTokenId.toString()))
                }
                if (sellAssetId != null) {
                    put("sell_asset_id", listOf(sellAssetId.toString()))
                }
                if (sellTokenAddress != null) {
                    put("sell_token_address", listOf(sellTokenAddress.toString()))
                }
                if (sellTokenName != null) {
                    put("sell_token_name", listOf(sellTokenName.toString()))
                }
                if (sellMinQuantity != null) {
                    put("sell_min_quantity", listOf(sellMinQuantity.toString()))
                }
                if (sellMaxQuantity != null) {
                    put("sell_max_quantity", listOf(sellMaxQuantity.toString()))
                }
                if (sellMetadata != null) {
                    put("sell_metadata", listOf(sellMetadata.toString()))
                }
                if (auxiliaryFeePercentages != null) {
                    put("auxiliary_fee_percentages", listOf(auxiliaryFeePercentages.toString()))
                }
                if (auxiliaryFeeRecipients != null) {
                    put("auxiliary_fee_recipients", listOf(auxiliaryFeeRecipients.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/orders",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a list of tokens
    * Get a list of tokens
    * @param address Contract address of the token (optional)
    * @param symbols Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH (optional)
    * @return ListTokensResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listTokens(address: kotlin.String?, symbols: kotlin.String?) : ListTokensResponse {
        val localVariableConfig = listTokensRequestConfig(address = address, symbols = symbols)

        val localVarResponse = request<Unit, ListTokensResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListTokensResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation listTokens
    *
    * @param address Contract address of the token (optional)
    * @param symbols Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH (optional)
    * @return RequestConfig
    */
    fun listTokensRequestConfig(address: kotlin.String?, symbols: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (address != null) {
                    put("address", listOf(address.toString()))
                }
                if (symbols != null) {
                    put("symbols", listOf(symbols.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/tokens",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a list of trades
    * Get a list of trades
    * @param partyATokenType Party A&#39;s sell token type (optional)
    * @param partyATokenAddress Party A&#39;s sell token address (optional)
    * @param partyATokenId Party A&#39;s sell token id (optional)
    * @param partyBTokenType Party B&#39;s sell token type (optional)
    * @param partyBTokenAddress Party B&#39;s sell token address (optional)
    * @param partyBTokenId Party B&#39;s sell token id (optional)
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param minTimestamp Minimum timestamp for this trade (optional)
    * @param maxTimestamp Maximum timestamp for this trade (optional)
    * @return ListTradesResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listTrades(partyATokenType: kotlin.String?, partyATokenAddress: kotlin.String?, partyATokenId: kotlin.String?, partyBTokenType: kotlin.String?, partyBTokenAddress: kotlin.String?, partyBTokenId: kotlin.String?, pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, minTimestamp: kotlin.String?, maxTimestamp: kotlin.String?) : ListTradesResponse {
        val localVariableConfig = listTradesRequestConfig(partyATokenType = partyATokenType, partyATokenAddress = partyATokenAddress, partyATokenId = partyATokenId, partyBTokenType = partyBTokenType, partyBTokenAddress = partyBTokenAddress, partyBTokenId = partyBTokenId, pageSize = pageSize, cursor = cursor, orderBy = orderBy, direction = direction, minTimestamp = minTimestamp, maxTimestamp = maxTimestamp)

        val localVarResponse = request<Unit, ListTradesResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListTradesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation listTrades
    *
    * @param partyATokenType Party A&#39;s sell token type (optional)
    * @param partyATokenAddress Party A&#39;s sell token address (optional)
    * @param partyATokenId Party A&#39;s sell token id (optional)
    * @param partyBTokenType Party B&#39;s sell token type (optional)
    * @param partyBTokenAddress Party B&#39;s sell token address (optional)
    * @param partyBTokenId Party B&#39;s sell token id (optional)
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param minTimestamp Minimum timestamp for this trade (optional)
    * @param maxTimestamp Maximum timestamp for this trade (optional)
    * @return RequestConfig
    */
    fun listTradesRequestConfig(partyATokenType: kotlin.String?, partyATokenAddress: kotlin.String?, partyATokenId: kotlin.String?, partyBTokenType: kotlin.String?, partyBTokenAddress: kotlin.String?, partyBTokenId: kotlin.String?, pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, minTimestamp: kotlin.String?, maxTimestamp: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (partyATokenType != null) {
                    put("party_a_token_type", listOf(partyATokenType.toString()))
                }
                if (partyATokenAddress != null) {
                    put("party_a_token_address", listOf(partyATokenAddress.toString()))
                }
                if (partyATokenId != null) {
                    put("party_a_token_id", listOf(partyATokenId.toString()))
                }
                if (partyBTokenType != null) {
                    put("party_b_token_type", listOf(partyBTokenType.toString()))
                }
                if (partyBTokenAddress != null) {
                    put("party_b_token_address", listOf(partyBTokenAddress.toString()))
                }
                if (partyBTokenId != null) {
                    put("party_b_token_id", listOf(partyBTokenId.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (orderBy != null) {
                    put("order_by", listOf(orderBy.toString()))
                }
                if (direction != null) {
                    put("direction", listOf(direction.toString()))
                }
                if (minTimestamp != null) {
                    put("min_timestamp", listOf(minTimestamp.toString()))
                }
                if (maxTimestamp != null) {
                    put("max_timestamp", listOf(maxTimestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/trades",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a list of transfers
    * Get a list of transfers
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param user Ethereum address of the user who submitted this transfer (optional)
    * @param status Status of this transfer (optional)
    * @param minTimestamp Minimum timestamp for this transfer (optional)
    * @param maxTimestamp Maximum timestamp for this transfer (optional)
    * @param tokenType Token type of the transferred asset (optional)
    * @param tokenId ERC721 Token ID of the minted asset (optional)
    * @param assetId Internal IMX ID of the minted asset (optional)
    * @param tokenAddress Token address of the transferred asset (optional)
    * @param tokenName Token name of the transferred asset (optional)
    * @param minQuantity Max quantity for the transferred asset (optional)
    * @param maxQuantity Max quantity for the transferred asset (optional)
    * @param metadata JSON-encoded metadata filters for the transferred asset (optional)
    * @return ListTransfersResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listTransfers(pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, user: kotlin.String?, status: kotlin.String?, minTimestamp: kotlin.String?, maxTimestamp: kotlin.String?, tokenType: kotlin.String?, tokenId: kotlin.String?, assetId: kotlin.String?, tokenAddress: kotlin.String?, tokenName: kotlin.String?, minQuantity: kotlin.String?, maxQuantity: kotlin.String?, metadata: kotlin.String?) : ListTransfersResponse {
        val localVariableConfig = listTransfersRequestConfig(pageSize = pageSize, cursor = cursor, orderBy = orderBy, direction = direction, user = user, status = status, minTimestamp = minTimestamp, maxTimestamp = maxTimestamp, tokenType = tokenType, tokenId = tokenId, assetId = assetId, tokenAddress = tokenAddress, tokenName = tokenName, minQuantity = minQuantity, maxQuantity = maxQuantity, metadata = metadata)

        val localVarResponse = request<Unit, ListTransfersResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListTransfersResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation listTransfers
    *
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param user Ethereum address of the user who submitted this transfer (optional)
    * @param status Status of this transfer (optional)
    * @param minTimestamp Minimum timestamp for this transfer (optional)
    * @param maxTimestamp Maximum timestamp for this transfer (optional)
    * @param tokenType Token type of the transferred asset (optional)
    * @param tokenId ERC721 Token ID of the minted asset (optional)
    * @param assetId Internal IMX ID of the minted asset (optional)
    * @param tokenAddress Token address of the transferred asset (optional)
    * @param tokenName Token name of the transferred asset (optional)
    * @param minQuantity Max quantity for the transferred asset (optional)
    * @param maxQuantity Max quantity for the transferred asset (optional)
    * @param metadata JSON-encoded metadata filters for the transferred asset (optional)
    * @return RequestConfig
    */
    fun listTransfersRequestConfig(pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, user: kotlin.String?, status: kotlin.String?, minTimestamp: kotlin.String?, maxTimestamp: kotlin.String?, tokenType: kotlin.String?, tokenId: kotlin.String?, assetId: kotlin.String?, tokenAddress: kotlin.String?, tokenName: kotlin.String?, minQuantity: kotlin.String?, maxQuantity: kotlin.String?, metadata: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (orderBy != null) {
                    put("order_by", listOf(orderBy.toString()))
                }
                if (direction != null) {
                    put("direction", listOf(direction.toString()))
                }
                if (user != null) {
                    put("user", listOf(user.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (minTimestamp != null) {
                    put("min_timestamp", listOf(minTimestamp.toString()))
                }
                if (maxTimestamp != null) {
                    put("max_timestamp", listOf(maxTimestamp.toString()))
                }
                if (tokenType != null) {
                    put("token_type", listOf(tokenType.toString()))
                }
                if (tokenId != null) {
                    put("token_id", listOf(tokenId.toString()))
                }
                if (assetId != null) {
                    put("asset_id", listOf(assetId.toString()))
                }
                if (tokenAddress != null) {
                    put("token_address", listOf(tokenAddress.toString()))
                }
                if (tokenName != null) {
                    put("token_name", listOf(tokenName.toString()))
                }
                if (minQuantity != null) {
                    put("min_quantity", listOf(minQuantity.toString()))
                }
                if (maxQuantity != null) {
                    put("max_quantity", listOf(maxQuantity.toString()))
                }
                if (metadata != null) {
                    put("metadata", listOf(metadata.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/transfers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a list of withdrawals
    * Get a list of withdrawals
    * @param withdrawnToWallet Withdrawal has been transferred to user&#39;s Layer 1 wallet (optional)
    * @param rollupStatus Status of the on-chain batch confirmation for this withdrawal (optional)
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param user Ethereum address of the user who submitted this withdrawal (optional)
    * @param status Status of this withdrawal (optional)
    * @param minTimestamp Minimum timestamp for this deposit (optional)
    * @param maxTimestamp Maximum timestamp for this deposit (optional)
    * @param tokenType Token type of the withdrawn asset (optional)
    * @param tokenId ERC721 Token ID of the minted asset (optional)
    * @param assetId Internal IMX ID of the minted asset (optional)
    * @param tokenAddress Token address of the withdrawn asset (optional)
    * @param tokenName Token name of the withdrawn asset (optional)
    * @param minQuantity Min quantity for the withdrawn asset (optional)
    * @param maxQuantity Max quantity for the withdrawn asset (optional)
    * @param metadata JSON-encoded metadata filters for the withdrawn asset (optional)
    * @return ListWithdrawalsResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listWithdrawals(withdrawnToWallet: kotlin.Boolean?, rollupStatus: kotlin.String?, pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, user: kotlin.String?, status: kotlin.String?, minTimestamp: kotlin.String?, maxTimestamp: kotlin.String?, tokenType: kotlin.String?, tokenId: kotlin.String?, assetId: kotlin.String?, tokenAddress: kotlin.String?, tokenName: kotlin.String?, minQuantity: kotlin.String?, maxQuantity: kotlin.String?, metadata: kotlin.String?) : ListWithdrawalsResponse {
        val localVariableConfig = listWithdrawalsRequestConfig(withdrawnToWallet = withdrawnToWallet, rollupStatus = rollupStatus, pageSize = pageSize, cursor = cursor, orderBy = orderBy, direction = direction, user = user, status = status, minTimestamp = minTimestamp, maxTimestamp = maxTimestamp, tokenType = tokenType, tokenId = tokenId, assetId = assetId, tokenAddress = tokenAddress, tokenName = tokenName, minQuantity = minQuantity, maxQuantity = maxQuantity, metadata = metadata)

        val localVarResponse = request<Unit, ListWithdrawalsResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListWithdrawalsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation listWithdrawals
    *
    * @param withdrawnToWallet Withdrawal has been transferred to user&#39;s Layer 1 wallet (optional)
    * @param rollupStatus Status of the on-chain batch confirmation for this withdrawal (optional)
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param user Ethereum address of the user who submitted this withdrawal (optional)
    * @param status Status of this withdrawal (optional)
    * @param minTimestamp Minimum timestamp for this deposit (optional)
    * @param maxTimestamp Maximum timestamp for this deposit (optional)
    * @param tokenType Token type of the withdrawn asset (optional)
    * @param tokenId ERC721 Token ID of the minted asset (optional)
    * @param assetId Internal IMX ID of the minted asset (optional)
    * @param tokenAddress Token address of the withdrawn asset (optional)
    * @param tokenName Token name of the withdrawn asset (optional)
    * @param minQuantity Min quantity for the withdrawn asset (optional)
    * @param maxQuantity Max quantity for the withdrawn asset (optional)
    * @param metadata JSON-encoded metadata filters for the withdrawn asset (optional)
    * @return RequestConfig
    */
    fun listWithdrawalsRequestConfig(withdrawnToWallet: kotlin.Boolean?, rollupStatus: kotlin.String?, pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, user: kotlin.String?, status: kotlin.String?, minTimestamp: kotlin.String?, maxTimestamp: kotlin.String?, tokenType: kotlin.String?, tokenId: kotlin.String?, assetId: kotlin.String?, tokenAddress: kotlin.String?, tokenName: kotlin.String?, minQuantity: kotlin.String?, maxQuantity: kotlin.String?, metadata: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (withdrawnToWallet != null) {
                    put("withdrawn_to_wallet", listOf(withdrawnToWallet.toString()))
                }
                if (rollupStatus != null) {
                    put("rollup_status", listOf(rollupStatus.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (orderBy != null) {
                    put("order_by", listOf(orderBy.toString()))
                }
                if (direction != null) {
                    put("direction", listOf(direction.toString()))
                }
                if (user != null) {
                    put("user", listOf(user.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (minTimestamp != null) {
                    put("min_timestamp", listOf(minTimestamp.toString()))
                }
                if (maxTimestamp != null) {
                    put("max_timestamp", listOf(maxTimestamp.toString()))
                }
                if (tokenType != null) {
                    put("token_type", listOf(tokenType.toString()))
                }
                if (tokenId != null) {
                    put("token_id", listOf(tokenId.toString()))
                }
                if (assetId != null) {
                    put("asset_id", listOf(assetId.toString()))
                }
                if (tokenAddress != null) {
                    put("token_address", listOf(tokenAddress.toString()))
                }
                if (tokenName != null) {
                    put("token_name", listOf(tokenName.toString()))
                }
                if (minQuantity != null) {
                    put("min_quantity", listOf(minQuantity.toString()))
                }
                if (maxQuantity != null) {
                    put("max_quantity", listOf(maxQuantity.toString()))
                }
                if (metadata != null) {
                    put("metadata", listOf(metadata.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/withdrawals",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Mint Tokens V2
    * Mint tokens in a batch with fees
    * @param mintTokensRequestV2 details of tokens to mint 
    * @return MintTokensResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun mintTokens(mintTokensRequestV2: kotlin.collections.List<MintRequest>) : MintTokensResponse {
        val localVariableConfig = mintTokensRequestConfig(mintTokensRequestV2 = mintTokensRequestV2)

        val localVarResponse = request<kotlin.collections.List<MintRequest>, MintTokensResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MintTokensResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation mintTokens
    *
    * @param mintTokensRequestV2 details of tokens to mint 
    * @return RequestConfig
    */
    fun mintTokensRequestConfig(mintTokensRequestV2: kotlin.collections.List<MintRequest>) : RequestConfig<kotlin.collections.List<MintRequest>> {
        val localVariableBody = mintTokensRequestV2
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/mints",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Registers a user
    * Registers a user
    * @param registerUserRequestVerifyEth Register User 
    * @return RegisterUserResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun registerUser(registerUserRequestVerifyEth: RegisterUserRequestVerifyEth) : RegisterUserResponse {
        val localVariableConfig = registerUserRequestConfig(registerUserRequestVerifyEth = registerUserRequestVerifyEth)

        val localVarResponse = request<RegisterUserRequestVerifyEth, RegisterUserResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RegisterUserResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation registerUser
    *
    * @param registerUserRequestVerifyEth Register User 
    * @return RequestConfig
    */
    fun registerUserRequestConfig(registerUserRequestVerifyEth: RegisterUserRequestVerifyEth) : RequestConfig<RegisterUserRequestVerifyEth> {
        val localVariableBody = registerUserRequestVerifyEth
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/users",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Update collection
    * Update collection
    * @param address Collection contract address 
    * @param imXSignature String created by signing wallet address and timestamp 
    * @param imXTimestamp Unix Epoc timestamp 
    * @param updateCollectionRequest update a collection 
    * @return Collection
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateCollection(address: kotlin.String, imXSignature: kotlin.String, imXTimestamp: kotlin.String, updateCollectionRequest: UpdateCollectionRequest) : Collection {
        val localVariableConfig = updateCollectionRequestConfig(address = address, imXSignature = imXSignature, imXTimestamp = imXTimestamp, updateCollectionRequest = updateCollectionRequest)

        val localVarResponse = request<UpdateCollectionRequest, Collection>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Collection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation updateCollection
    *
    * @param address Collection contract address 
    * @param imXSignature String created by signing wallet address and timestamp 
    * @param imXTimestamp Unix Epoc timestamp 
    * @param updateCollectionRequest update a collection 
    * @return RequestConfig
    */
    fun updateCollectionRequestConfig(address: kotlin.String, imXSignature: kotlin.String, imXTimestamp: kotlin.String, updateCollectionRequest: UpdateCollectionRequest) : RequestConfig<UpdateCollectionRequest> {
        val localVariableBody = updateCollectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        imXSignature.apply { localVariableHeaders["IMX-Signature"] = this.toString() }
        imXTimestamp.apply { localVariableHeaders["IMX-Timestamp"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/v1/collections/{address}".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Update metadata schema by name
    * Update metadata schema by name
    * @param address Collection contract address 
    * @param name Metadata schema name 
    * @param imXSignature String created by signing wallet address and timestamp 
    * @param imXTimestamp Unix Epoc timestamp 
    * @param metadataSchemaRequest update metadata schema 
    * @return SuccessResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateMetadataSchemaByName(address: kotlin.String, name: kotlin.String, imXSignature: kotlin.String, imXTimestamp: kotlin.String, metadataSchemaRequest: MetadataSchemaRequest) : SuccessResponse {
        val localVariableConfig = updateMetadataSchemaByNameRequestConfig(address = address, name = name, imXSignature = imXSignature, imXTimestamp = imXTimestamp, metadataSchemaRequest = metadataSchemaRequest)

        val localVarResponse = request<MetadataSchemaRequest, SuccessResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SuccessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation updateMetadataSchemaByName
    *
    * @param address Collection contract address 
    * @param name Metadata schema name 
    * @param imXSignature String created by signing wallet address and timestamp 
    * @param imXTimestamp Unix Epoc timestamp 
    * @param metadataSchemaRequest update metadata schema 
    * @return RequestConfig
    */
    fun updateMetadataSchemaByNameRequestConfig(address: kotlin.String, name: kotlin.String, imXSignature: kotlin.String, imXTimestamp: kotlin.String, metadataSchemaRequest: MetadataSchemaRequest) : RequestConfig<MetadataSchemaRequest> {
        val localVariableBody = metadataSchemaRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        imXSignature.apply { localVariableHeaders["IMX-Signature"] = this.toString() }
        imXTimestamp.apply { localVariableHeaders["IMX-Timestamp"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/v1/collections/{address}/metadata-schema/{name}".replace("{"+"address"+"}", "$address").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
