/**
 * Immutable X API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * Contact: support@immutable.com
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.immutable.sdk.api

import com.immutable.sdk.api.model.CreateTradeRequestV1
import com.immutable.sdk.api.model.CreateTradeResponse
import com.immutable.sdk.api.model.GetSignableTradeRequest
import com.immutable.sdk.api.model.GetSignableTradeResponse
import com.immutable.sdk.api.model.ListTradesResponse
import com.immutable.sdk.api.model.Trade

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiErrorModel
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class TradesApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("org.openapitools.client.baseUrl", "http://api.ropsten.x.immutable.com")
        }
    }

    /**
    * Create a Trade between two parties
    * Create a Trade
    * @param createTradeRequest create a trade 
    * @param xImxEthAddress eth address (optional)
    * @param xImxEthSignature eth signature (optional)
    * @return CreateTradeResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createTrade(createTradeRequest: CreateTradeRequestV1, xImxEthAddress: kotlin.String? = null, xImxEthSignature: kotlin.String? = null) : CreateTradeResponse {
        val localVariableConfig = createTradeRequestConfig(createTradeRequest = createTradeRequest, xImxEthAddress = xImxEthAddress, xImxEthSignature = xImxEthSignature)

        val localVarResponse = request<CreateTradeRequestV1, CreateTradeResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateTradeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                val errorModel = localVarError.body?.let { ApiErrorModel(localVarError.body) }
                throw ClientException("${localVarError.statusCode} ${errorModel?.message ?: localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse, errorModel)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                val errorModel = localVarError.body?.let { ApiErrorModel(localVarError.body) }
                throw ServerException("${localVarError.statusCode} ${errorModel?.message ?: localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse, errorModel)
            }
        }
    }

    /**
    * To obtain the request config of the operation createTrade
    *
    * @param createTradeRequest create a trade 
    * @param xImxEthAddress eth address (optional)
    * @param xImxEthSignature eth signature (optional)
    * @return RequestConfig
    */
    fun createTradeRequestConfig(createTradeRequest: CreateTradeRequestV1, xImxEthAddress: kotlin.String?, xImxEthSignature: kotlin.String?) : RequestConfig<CreateTradeRequestV1> {
        val localVariableBody = createTradeRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xImxEthAddress?.apply { localVariableHeaders["x-imx-eth-address"] = this.toString() }
        xImxEthSignature?.apply { localVariableHeaders["x-imx-eth-signature"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/trades",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get details a signable trade V3
    * Get details a signable trade V3
    * @param getSignableTradeRequest get a signable trade 
    * @return GetSignableTradeResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSignableTrade(getSignableTradeRequest: GetSignableTradeRequest) : GetSignableTradeResponse {
        val localVariableConfig = getSignableTradeRequestConfig(getSignableTradeRequest = getSignableTradeRequest)

        val localVarResponse = request<GetSignableTradeRequest, GetSignableTradeResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetSignableTradeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                val errorModel = localVarError.body?.let { ApiErrorModel(localVarError.body) }
                throw ClientException("${localVarError.statusCode} ${errorModel?.message ?: localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse, errorModel)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                val errorModel = localVarError.body?.let { ApiErrorModel(localVarError.body) }
                throw ServerException("${localVarError.statusCode} ${errorModel?.message ?: localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse, errorModel)
            }
        }
    }

    /**
    * To obtain the request config of the operation getSignableTrade
    *
    * @param getSignableTradeRequest get a signable trade 
    * @return RequestConfig
    */
    fun getSignableTradeRequestConfig(getSignableTradeRequest: GetSignableTradeRequest) : RequestConfig<GetSignableTradeRequest> {
        val localVariableBody = getSignableTradeRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v3/signable-trade-details",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get details of a trade with the given ID
    * Get details of a trade with the given ID
    * @param id Trade ID 
    * @return Trade
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTrade(id: kotlin.String) : Trade {
        val localVariableConfig = getTradeRequestConfig(id = id)

        val localVarResponse = request<Unit, Trade>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Trade
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                val errorModel = localVarError.body?.let { ApiErrorModel(localVarError.body) }
                throw ClientException("${localVarError.statusCode} ${errorModel?.message ?: localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse, errorModel)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                val errorModel = localVarError.body?.let { ApiErrorModel(localVarError.body) }
                throw ServerException("${localVarError.statusCode} ${errorModel?.message ?: localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse, errorModel)
            }
        }
    }

    /**
    * To obtain the request config of the operation getTrade
    *
    * @param id Trade ID 
    * @return RequestConfig
    */
    fun getTradeRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/trades/{id}".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a list of trades
    * Get a list of trades
    * @param partyATokenType Party A&#39;s sell token type (optional)
    * @param partyATokenAddress Party A&#39;s sell token address (optional)
    * @param partyATokenId Party A&#39;s sell token id (optional)
    * @param partyBTokenType Party B&#39;s sell token type (optional)
    * @param partyBTokenAddress Party B&#39;s sell token address (optional)
    * @param partyBTokenId Party B&#39;s sell token id (optional)
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param minTimestamp Minimum timestamp for this trade (optional)
    * @param maxTimestamp Maximum timestamp for this trade (optional)
    * @return ListTradesResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listTrades(partyATokenType: kotlin.String? = null, partyATokenAddress: kotlin.String? = null, partyATokenId: kotlin.String? = null, partyBTokenType: kotlin.String? = null, partyBTokenAddress: kotlin.String? = null, partyBTokenId: kotlin.String? = null, pageSize: kotlin.Int? = null, cursor: kotlin.String? = null, orderBy: kotlin.String? = null, direction: kotlin.String? = null, minTimestamp: kotlin.String? = null, maxTimestamp: kotlin.String? = null) : ListTradesResponse {
        val localVariableConfig = listTradesRequestConfig(partyATokenType = partyATokenType, partyATokenAddress = partyATokenAddress, partyATokenId = partyATokenId, partyBTokenType = partyBTokenType, partyBTokenAddress = partyBTokenAddress, partyBTokenId = partyBTokenId, pageSize = pageSize, cursor = cursor, orderBy = orderBy, direction = direction, minTimestamp = minTimestamp, maxTimestamp = maxTimestamp)

        val localVarResponse = request<Unit, ListTradesResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListTradesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                val errorModel = localVarError.body?.let { ApiErrorModel(localVarError.body) }
                throw ClientException("${localVarError.statusCode} ${errorModel?.message ?: localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse, errorModel)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                val errorModel = localVarError.body?.let { ApiErrorModel(localVarError.body) }
                throw ServerException("${localVarError.statusCode} ${errorModel?.message ?: localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse, errorModel)
            }
        }
    }

    /**
    * To obtain the request config of the operation listTrades
    *
    * @param partyATokenType Party A&#39;s sell token type (optional)
    * @param partyATokenAddress Party A&#39;s sell token address (optional)
    * @param partyATokenId Party A&#39;s sell token id (optional)
    * @param partyBTokenType Party B&#39;s sell token type (optional)
    * @param partyBTokenAddress Party B&#39;s sell token address (optional)
    * @param partyBTokenId Party B&#39;s sell token id (optional)
    * @param pageSize Page size of the result (optional)
    * @param cursor Cursor (optional)
    * @param orderBy Property to sort by (optional)
    * @param direction Direction to sort (asc/desc) (optional)
    * @param minTimestamp Minimum timestamp for this trade (optional)
    * @param maxTimestamp Maximum timestamp for this trade (optional)
    * @return RequestConfig
    */
    fun listTradesRequestConfig(partyATokenType: kotlin.String?, partyATokenAddress: kotlin.String?, partyATokenId: kotlin.String?, partyBTokenType: kotlin.String?, partyBTokenAddress: kotlin.String?, partyBTokenId: kotlin.String?, pageSize: kotlin.Int?, cursor: kotlin.String?, orderBy: kotlin.String?, direction: kotlin.String?, minTimestamp: kotlin.String?, maxTimestamp: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (partyATokenType != null) {
                    put("party_a_token_type", listOf(partyATokenType.toString()))
                }
                if (partyATokenAddress != null) {
                    put("party_a_token_address", listOf(partyATokenAddress.toString()))
                }
                if (partyATokenId != null) {
                    put("party_a_token_id", listOf(partyATokenId.toString()))
                }
                if (partyBTokenType != null) {
                    put("party_b_token_type", listOf(partyBTokenType.toString()))
                }
                if (partyBTokenAddress != null) {
                    put("party_b_token_address", listOf(partyBTokenAddress.toString()))
                }
                if (partyBTokenId != null) {
                    put("party_b_token_id", listOf(partyBTokenId.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (orderBy != null) {
                    put("order_by", listOf(orderBy.toString()))
                }
                if (direction != null) {
                    put("direction", listOf(direction.toString()))
                }
                if (minTimestamp != null) {
                    put("min_timestamp", listOf(minTimestamp.toString()))
                }
                if (maxTimestamp != null) {
                    put("max_timestamp", listOf(maxTimestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/trades",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
